import itertools
import numpy as np
import sys
import cvxpy as cp


class Points:
    def __init__(self, x_coordinate, y_coordinate):
        self.x_coordinate = x_coordinate
        self.y_coordinate = y_coordinate

    def __str__(self):
        return f"({self.x_coordinate}, {self.y_coordinate})"


def calculate_distance(point1, point2):
    x_distance = 1.1 * abs(point1.x_coordinate - point2.x_coordinate)
    y_distance = abs(point1.y_coordinate - point2.y_coordinate)
    return max(x_distance, y_distance)


def get_points(file_path):
    points = [Points(0, 0)]
    with open(file_path, "r") as file:
        num_of_points = int(file.readline().strip())
        for _ in range(1, num_of_points + 1):
            _, x, y = file.readline().split()
            points.append(Points(float(x), float(y)))
    return points


def create_distance_matrix(points):
    n = len(points)
    dists = np.zeros((n, n))
    for i in range(n):
        for j in range(i + 1, n):
            dists[i, j] = dists[j, i] = calculate_distance(points[i], points[j])
    return dists


def held_karp_tsp(distance_matrix):
    num_vertices = len(distance_matrix)
    edges_costs = {
        (i, j): distance_matrix[i][j]
        for i in range(num_vertices)
        for j in range(i + 1, num_vertices)
    }

    # Define decision variables for each edge
    x = {e: cp.Variable(name=f"x_{e[0]}_{e[1]}", boolean=True) for e in edges_costs}

    # Objective: Minimize total distance
    cost = cp.sum([edges_costs[e] * x[e] for e in edges_costs])

    # Constraints
    constraints = []

    # Degree constraints: each vertex must have exactly two incident edges
    for v in range(num_vertices):
        incident_edges = [
            x[min(v, u), max(v, u)] for u in range(num_vertices) if u != v
        ]
        constraints.append(cp.sum(incident_edges) == 2)

    # Define the problem and solve it
    problem = cp.Problem(cp.Minimize(cost), constraints)
    problem.solve()  # Not specifying a solver, it will choose the default one

    # Extract solution
    solution = {e: x[e].value for e in edges_costs if x[e].value > 0.5}
    return solution, problem.value


# Example usage
file_path = "data\d159.dat"  # Update with the path to your data file
points = get_points(file_path)
distance_matrix = create_distance_matrix(points)
solution, minimum_cost = held_karp_tsp(distance_matrix)
print("Used Edges in Solution:")
for edge, use in solution.items():
    print(f"Edge {edge}: Used")
print(f"Minimum cost: {minimum_cost}")
